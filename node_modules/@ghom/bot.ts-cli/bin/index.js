#!/usr/bin/env node
'use strict';

var commander = require('commander');
var dotenv = require('dotenv');
var path = require('node:path');
var url = require('node:url');
var cp = require('node:child_process');
var prompts = require('@inquirer/prompts');
var ejs = require('ejs');
var loading = require('loading-cli');
var fs = require('node:fs');
var fsp = require('node:fs/promises');
var util = require('node:util');
var prettier = require('prettier');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var util__namespace = /*#__PURE__*/_interopNamespaceDefault(util);

const dirname$1 = path.dirname(url.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('index.js', document.baseURI).href))));
const root = (...segments) => path.join(dirname$1, "..", ...segments);
const cwd = (...segments) => path.join(process.cwd(), ...segments);
function inputName(message, options) {
    return prompts.input({
        message: `${message} ${util.styleText("grey", options?.column
            ? "(in snake_case)"
            : options?.main
                ? "(used as directory/package.json name)"
                : "(used as filename)")}`,
        required: true,
        default: options?.defaultValue,
        validate: (value) => options?.column
            ? /^[a-z]+[a-z0-9_]*$/.test(value) || "Must be in snake_case"
            : options?.kebabCase
                ? /^[a-z]+[a-z0-9-]*$/.test(value) || "Must be in kebab-case"
                : /^[a-z]+[a-zA-Z0-9]*$/.test(value) || "Must be in camelCase",
    });
}
function isNodeLikeProject(projectPath = cwd()) {
    return fs.existsSync(path.join(projectPath, "package.json"));
}
function isBotTsProject() {
    let packageJson;
    try {
        packageJson = readJSON(cwd("package.json"));
    }
    catch {
        console.error(util.styleText("red", 'You should only use this command at the root of a "bot.ts" project'));
        return false;
    }
    if (!packageJson.devDependencies?.hasOwnProperty("@ghom/bot.ts-cli")) {
        console.error(util.styleText("red", 'This project does not seem to be a "bot.ts" project'));
        return false;
    }
    return fs.existsSync(cwd("compatibility.json"));
}
function getDatabaseDriverName(packageJson) {
    if (packageJson?.dependencies?.["pg"]) {
        return "pg";
    }
    else if (packageJson?.dependencies?.["mysql2"]) {
        return "mysql2";
    }
    else if (packageJson?.dependencies?.["sqlite3"]) {
        return "sqlite3";
    }
    else
        throw new Error("No database driver found in package.json");
}
function readJSON(srcPath) {
    return JSON.parse(fs.readFileSync(srcPath, "utf8"));
}
function writeJSON(destPath, json) {
    fs.writeFileSync(destPath, JSON.stringify(json, null, 2), "utf8");
}
function capitalize(str) {
    return str[0].toUpperCase() + str.slice(1);
}
async function loader(start, callback, end) {
    const time = Date.now();
    const load = loading({
        text: util.styleText("bold", start),
        interval: 150,
        color: "white",
        frames: ["‚óê", "‚óì", "‚óë", "‚óí"],
    }).start();
    await callback();
    load.succeed(`${util.styleText("bold", end)} ${util.styleText("grey", `${Date.now() - time}ms`)}`);
}
async function injectEnvLine(name, value, projectPath = cwd()) {
    const env = await fsp.readFile(path.join(projectPath, ".env"), "utf8");
    const lines = env.split("\n");
    const index = lines.findIndex((line) => line.split("=")[0] === name);
    if (index > -1)
        lines.splice(index, 1);
    lines.push(`${name}="${value}"`);
    await fsp.writeFile(path.join(projectPath, ".env"), lines.join("\n"), "utf8");
}
function format(str) {
    return prettier.format(str, {
        parser: "typescript",
        semi: false,
        endOfLine: "crlf",
    });
}
async function promptDatabase() {
    const client = await prompts.select({
        message: "Select the database client",
        choices: [
            { value: "sqlite3", name: "SQLite" },
            { value: "pg", name: "PostgreSQL" },
            { value: "mysql2", name: "MySQL" },
        ],
        default: "sqlite3",
    });
    let database = {};
    if (client !== "sqlite3") {
        database.host = await prompts.input({
            message: "Enter the database host",
            default: "127.0.0.1",
        });
        database.port = await prompts.input({
            message: "Enter the database port",
            default: client === "pg" ? "5432" : "3306",
        });
        database.user = await prompts.input({
            message: "Enter the database user",
            default: client === "pg" ? "postgres" : "root",
        });
        database.password = await prompts.password({
            message: "Enter the database password",
        });
        database.database = await prompts.input({
            message: "Enter the database/schema name",
            default: client === "pg" ? "postgres" : undefined,
            required: client !== "pg",
        });
    }
    return { database, client };
}
async function promptEngine() {
    const runtime = await prompts.select({
        message: "Select the JavaScript runtime",
        choices: [
            { value: "node", name: "Node.js" },
            { value: "deno", name: "Deno" },
            { value: "bun", name: "Bun (recommended)" },
        ],
        default: "node",
    });
    let list = ["npm", "yarn", "pnpm"];
    if (runtime !== "node")
        list.unshift(runtime);
    const packageManager = await prompts.select({
        message: "Select the package manager",
        choices: list.map((pm, index) => ({
            value: pm,
            name: index === 0 ? `${pm} (recommended)` : pm,
        })),
        default: list[0],
    });
    return { runtime, packageManager };
}
async function setupDatabase(database, projectPath = cwd()) {
    const packageJson = readJSON(path.join(projectPath, "package.json"));
    if (!packageJson.dependencies)
        packageJson.dependencies = {};
    // delete all other database dependencies.
    for (const dbname of ["sqlite3", "mysql2", "pg"]) {
        if (dbname !== database.client)
            delete packageJson.dependencies[dbname];
        else
            packageJson.dependencies[dbname] = "latest";
    }
    writeJSON(path.join(projectPath, "package.json"), packageJson);
    const template = await fsp.readFile(path.join(projectPath, "templates", "database.ejs"), "utf8");
    await fsp.writeFile(path.join(projectPath, "src", "core", "database.ts"), format(ejs.compile(template)({
        client: database.client,
    })), "utf8");
    if (database.host)
        await injectEnvLine("DB_HOST", database.host, projectPath);
    if (database.port)
        await injectEnvLine("DB_PORT", database.port, projectPath);
    if (database.user)
        await injectEnvLine("DB_USER", database.user, projectPath);
    if (database.password)
        await injectEnvLine("DB_PASSWORD", database.password, projectPath);
    if (database.database)
        await injectEnvLine("DB_DATABASE", database.database, projectPath);
}
async function setupEngine(config, options, projectPath = cwd()) {
    await injectEnvLine("RUNTIME", config.runtime, projectPath);
    await injectEnvLine("PACKAGE_MANAGER", config.packageManager, projectPath);
    const compatibility = readJSON(path.join(projectPath, "compatibility.json"));
    for (const lockfile of Object.values(compatibility.components["lockfile"])) {
        try {
            await fsp.unlink(path.join(projectPath, lockfile));
        }
        catch { }
    }
    cp.execSync(compatibility.components["install"][config.packageManager], {
        stdio: ["ignore", "ignore", "pipe"],
        cwd: projectPath,
    });
    await setupWorkflow(config, projectPath);
    if (options.setupDocker)
        await setupDocker(config, projectPath);
    return await setupScripts(config, projectPath);
}
/**
 * Generate pacakge.json scripts from compatibility.json and return the compatibility json components.
 */
async function setupScripts(config, projectPath = cwd()) {
    const packageJsonPath = path.join(projectPath, "package.json");
    const compatibilityJsonPath = path.join(projectPath, "compatibility.json");
    const { templates, components } = readJSON(compatibilityJsonPath);
    const generateScripts = () => {
        const scripts = {};
        for (const [key, value] of Object.entries(templates)) {
            if (typeof value === "string") {
                scripts[key] = replaceTags(value);
            }
            else if (typeof value === "object") {
                scripts[key] = replaceTags(value[config.runtime] ?? value.default);
            }
        }
        return scripts;
    };
    const replaceTags = (template) => {
        return template.replace(/{([a-z-]+)}/g, (_, tag) => {
            if (components[tag]) {
                if ("node" in components[tag]) {
                    return components[tag][config.runtime];
                }
                else {
                    return components[tag][config.packageManager];
                }
            }
            else {
                throw new Error(`Tag "${tag}" not found in compatibility.json, please remove the tag from the file.`);
            }
        });
    };
    const generatedScripts = generateScripts();
    const packageJson = JSON.parse(await fsp.readFile(packageJsonPath, "utf-8"));
    packageJson.scripts = {
        ...packageJson.scripts,
        ...generatedScripts,
    };
    await fsp.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2), "utf-8");
    return components;
}
async function setupDocker(config, projectPath = cwd()) {
    config.client ??= getDatabaseDriverName(readJSON(path.join(projectPath, "package.json")));
    const [dockerfile, compose] = await Promise.all([
        fsp.readFile(path.join(projectPath, "templates", "dockerfile.ejs"), "utf8"),
        fsp.readFile(path.join(projectPath, "templates", "compose.ejs"), "utf8"),
    ]);
    await fsp.writeFile(path.join(projectPath, "Dockerfile"), ejs.compile(dockerfile)(config), "utf8");
    await fsp.writeFile(path.join(projectPath, "docker-compose.yml"), ejs.compile(compose)(config), "utf8");
}
async function setupWorkflow(config, projectPath = cwd()) {
    const template = await fsp.readFile(path.join(projectPath, "templates", "workflow.ejs"), "utf8");
    await fsp.writeFile(path.join(projectPath, ".github", "workflows", "tests.yml"), ejs.compile(template)(config), "utf8");
}

const handler$8 = async () => {
    if (!isBotTsProject())
        return process.exit(1);
    const name = await inputName("Enter a name for the button");
    const description = await prompts.input({
        message: "Enter a description for the button",
    });
    const label = await prompts.input({
        message: "Enter the text to display on the button",
        required: true,
    });
    let endParams = false;
    const params = {};
    while (!endParams) {
        const addMore = await prompts.confirm({
            message: `Do you want to add ${"" }parameters?`,
        });
        if (addMore) {
            const paramName = await prompts.input({
                message: "Enter a parameter name",
            });
            const paramType = await prompts.select({
                message: "Select a parameter type",
                choices: [
                    { name: "String", value: "string" },
                    { name: "Number", value: "number" },
                    { name: "Boolean", value: "boolean" },
                ],
            });
            const optional = await prompts.confirm({
                message: "Is this parameter optional?",
                default: false,
            });
            params[paramName + (optional ? "?" : "")] = paramType;
        }
        else {
            endParams = true;
        }
    }
    const template = fs.readFileSync(cwd("templates", "button.ejs"), "utf8");
    const buttonPath = ["src", "buttons", name + ".ts"];
    fs.writeFileSync(cwd(...buttonPath), format(ejs.compile(template)({
        name,
        Name: capitalize(name),
        description,
        params,
        label,
    })), "utf8");
    console.log();
    console.log(`‚úÖ Button ${util.styleText("blueBright", name)} has been created at ${util.styleText("cyanBright", path.join(...buttonPath))}`);
};
const command$b = new commander.Command("button")
    .description("Add a button\nMore info: https://ghom.gitbook.io/bot.ts/usage/create-a-button")
    .usage("[--options]")
    .action(handler$8);

const handler$7 = async () => {
    if (!isBotTsProject())
        return process.exit(1);
    const name = await inputName("Enter the command name");
    const description = await prompts.input({
        message: "Enter the command description",
    });
    const channelType = await prompts.select({
        message: "Select the channel type",
        choices: [
            { name: "All Channels", value: "all" },
            { name: "Direct Messages", value: "dm" },
            { name: "Guild Channels", value: "guild" },
        ],
        default: "all",
    });
    const botOwnerOnly = await prompts.confirm({
        message: "Is this command for bot owner only?",
        default: false,
    });
    const template = fs.readFileSync(cwd("templates", "command.ejs"), "utf8");
    const commandPath = ["src", "commands", name + ".ts"];
    fs.writeFileSync(cwd(...commandPath), format(ejs.compile(template)({
        name,
        description,
        channelType,
        botOwnerOnly,
    })), "utf8");
    console.log();
    console.log(`‚úÖ Command ${util.styleText("blueBright", name)} has been created at ${util.styleText("cyanBright", path.join(...commandPath))}`);
};
const command$a = new commander.Command("command")
    .description("Add a command\nMore info: https://ghom.gitbook.io/bot.ts/usage/create-a-command")
    .usage("[--options]")
    .action(handler$7);

const handler$6 = async () => {
    if (!isBotTsProject())
        return process.exit(1);
    const name = await inputName("Enter a name for the cron job");
    const description = await prompts.input({
        message: "Enter a description for the cron job",
    });
    const scheduleType = await prompts.select({
        message: "Select a schedule type",
        choices: [
            {
                value: '"hourly"',
                name: `Simple ${util.styleText("grey", "(hourly, daily, weekly...)")}`,
            },
            {
                value: '{ type: "hour", duration: 2 } // every 2 hours',
                name: `Advanced ${util.styleText("grey", "(each X minutes, hours, days...)")}`,
            },
            {
                value: "{ second: 0, minute: 0, hour: 12 } // everyday at noon",
                name: `Custom ${util.styleText("grey", "(cron expression)")}`,
            },
        ],
    });
    const template = fs.readFileSync(cwd("templates", "cron.ejs"), "utf8");
    const cronPath = ["src", "cron", name + ".ts"];
    fs.writeFileSync(cwd(...cronPath), format(ejs.compile(template)({
        name,
        Name: capitalize(name),
        description,
        scheduleType,
    })), "utf8");
    console.log();
    console.log(`‚úÖ Cron job ${util.styleText("blueBright", name)} has been created at ${util.styleText("cyanBright", path.join(...cronPath))}`);
};
const command$9 = new commander.Command("cron")
    .description("Add a cron job\nMore info: https://ghom.gitbook.io/bot.ts/usage/create-a-cron")
    .usage("[--options]")
    .action(handler$6);

const handler$5 = async () => {
    if (!isBotTsProject())
        return process.exit(1);
    const events = readJSON(root("events.json"));
    const event = await prompts.select({
        message: "Enter the event name",
        choices: Object.keys(events).map((event) => ({
            name: event,
            value: event,
        })),
    });
    const category = await inputName(`Enter a category name ${util.styleText("grey", "(tracker, mod, etc)")}`);
    const once = await prompts.confirm({
        message: `Is this a one-time listener? ${util.styleText("grey", "(like on ready)")}`,
        default: false,
    });
    const description = await prompts.input({
        message: "Enter the listener description",
        required: false,
    });
    const args = events[event];
    const filename = [category, event].filter(Boolean).join(".");
    const template = fs.readFileSync(cwd("templates", "listener.ejs"), "utf8");
    const listenerPath = ["src", "listeners", filename + ".ts"];
    fs.writeFileSync(cwd(...listenerPath), format(ejs.compile(template)({
        event,
        once,
        description,
        args: Array.isArray(args) ? args : [args],
    })), "utf8");
    console.log();
    console.log(`‚úÖ Listener ${util.styleText("blueBright", event)} has been created at ${util.styleText("cyanBright", path.join(...listenerPath))}`);
};
const command$8 = new commander.Command("listener")
    .description("Add a listener\nMore info: https://ghom.gitbook.io/bot.ts/usage/create-a-listener")
    .usage("[--options]")
    .action(handler$5);

const handler$4 = async () => {
    if (!isBotTsProject())
        return process.exit(1);
    const name = await inputName("Enter the namespace name");
    const importCore = await prompts.confirm({
        message: "Do you want to import core?",
        default: false,
    });
    const template = fs.readFileSync(cwd("templates", "namespace.ejs"), "utf8");
    const namespacePath = ["src", "namespaces", name + ".ts"];
    fs.writeFileSync(cwd(...namespacePath), format(ejs.compile(template)({ importCore })), "utf8");
    console.log();
    console.log(`‚úÖ Namespace ${util.styleText("blueBright", name)} has been created at ${util.styleText("cyanBright", path.join(...namespacePath))}`);
};
const command$7 = new commander.Command("namespace")
    .description("Add a namespace\nMore info: https://ghom.gitbook.io/bot.ts/usage/create-a-namespace")
    .usage("[--options]")
    .action(handler$4);

const handler$3 = async () => {
    if (!isBotTsProject())
        return process.exit(1);
    const name = await inputName("Enter the command name");
    const description = await prompts.input({
        message: "Enter the command description",
    });
    const guildOnly = await prompts.confirm({
        message: "Is this command for guilds only?",
        default: false,
    });
    const botOwnerOnly = await prompts.confirm({
        message: "Is this command for bot owner only?",
        default: false,
    });
    const withSubs = await prompts.confirm({
        message: "Does this command have subcommands or options?",
        default: false,
    });
    const template = fs.readFileSync(cwd("templates", "slash.ejs"), "utf8");
    const slashPath = ["src", "slash", name + ".ts"];
    fs.writeFileSync(cwd(...slashPath), format(ejs.compile(template)({
        name,
        description,
        guildOnly,
        botOwnerOnly,
        withSubs,
    })), "utf8");
    console.log();
    console.log(`‚úÖ Slash command ${util.styleText("blueBright", name)} has been created at ${util.styleText("cyanBright", path.join(...slashPath))}`);
};
const command$6 = new commander.Command("slash")
    .description("Add a slash command\nMore info: https://ghom.gitbook.io/bot.ts/usage/create-a-command#slash-commands")
    .usage("[--options]")
    .action(handler$3);

const TYPES = [
    "string",
    "integer",
    "float",
    "boolean",
    "date",
    "json",
    "bigint",
];
const handler$2 = async () => {
    if (!isBotTsProject())
        return process.exit(1);
    const name = await inputName("Enter the table name");
    const description = await prompts.input({
        message: "Enter the table description",
    });
    const priority = await prompts.number({
        message: `Enter the computing priority for relations ${util.styleText("grey", "(higher is computed first)")}`,
        default: 0,
    });
    const columns = {};
    let addColumn = true, firstColumn = true;
    while (addColumn) {
        const category = await prompts.select({
            message: `Choose the ${firstColumn ? "first" : "next"} column category`,
            choices: [
                {
                    name: `Data column ${util.styleText("grey", "(default)")}`,
                    value: "data",
                },
                { name: "Relation column", value: "relation" },
                {
                    name: `Primary column ${util.styleText("grey", "(e.g. auto increments)")}`,
                    value: "primary",
                },
            ],
            default: "data",
        });
        switch (category) {
            case "data": {
                const name = await inputName("Enter the column name", {
                    column: true,
                });
                const typeFn = await prompts.select({
                    message: "Enter the column type",
                    choices: TYPES.map((t) => ({ name: t, value: t })),
                });
                const required = await prompts.confirm({
                    message: "Is this column required?",
                    default: false,
                });
                const unique = await prompts.confirm({
                    message: "Is this column unique?",
                    default: false,
                });
                columns[name] = {
                    category,
                    typeFn,
                    required,
                    unique,
                    type: typeFromTypeFn(typeFn),
                };
                break;
            }
            case "relation": {
                const tableName = await prompts.input({
                    message: "Enter the related table name",
                    required: true,
                    async validate(value) {
                        if (!fs.existsSync(cwd("src", "tables", value + ".ts"))) {
                            return `Table ${value} does not exist`;
                        }
                        return true;
                    },
                });
                // TODO: resolve the columns of the targetted table and use a select
                const tableColumn = await prompts.input({
                    message: `Enter the related ${util.styleText("blueBright", tableName)}'s column name`,
                    required: true,
                });
                // TODO: resolve the type of the column from the targetted table
                const typeFn = await prompts.select({
                    message: `Enter the related ${util.styleText("blueBright", tableName + "." + tableColumn)}'s type`,
                    choices: TYPES.map((t) => ({ name: t, value: t })),
                    default: "integer",
                });
                const name = await inputName("Enter the relation name", {
                    defaultValue: tableName + "_" + tableColumn,
                    column: true,
                });
                const deleteCascade = await prompts.confirm({
                    message: "Should the relation cascade on delete?",
                    default: false,
                });
                columns[name] = {
                    category,
                    tableName,
                    tableColumn,
                    name,
                    typeFn,
                    type: typeFromTypeFn(typeFn),
                    required: true,
                    deleteCascade,
                };
                break;
            }
            case "primary": {
                const name = await inputName("Enter the primary column name", {
                    defaultValue: "id",
                    column: true,
                });
                const auto = await prompts.confirm({
                    message: "Is this column auto incrementing?",
                    default: true,
                });
                if (!auto) {
                    const typeFn = await prompts.select({
                        message: "Enter the primary column type",
                        choices: TYPES.map((t) => ({ name: t, value: t })),
                    });
                    columns[name] = {
                        category,
                        typeFn,
                        type: typeFromTypeFn(typeFn),
                        required: true,
                    };
                }
                else {
                    columns[name] = { category, auto, type: "number", required: true };
                }
                break;
            }
        }
        const moreColumns = await prompts.confirm({
            message: "Do you want to add another column?",
            default: true,
        });
        addColumn = moreColumns;
        firstColumn = false;
    }
    const template = fs.readFileSync(cwd("templates", "table.ejs"), "utf8");
    const buttonPath = ["src", "tables", name + ".ts"];
    fs.writeFileSync(cwd(...buttonPath), format(ejs.compile(template)({
        name,
        Name: capitalize(name),
        description,
        priority,
        columns,
    })), "utf8");
    console.log();
    console.log(`‚úÖ Table ${util.styleText("blueBright", name)} has been created at ${util.styleText("cyanBright", path.join(...buttonPath))}`);
};
const command$5 = new commander.Command("table")
    .description("Add a database table\nMore info: https://ghom.gitbook.io/bot.ts/usage/use-database#create-a-table")
    .usage("[--options]")
    .action(handler$2);
function typeFromTypeFn(typeFn) {
    switch (typeFn) {
        case "integer":
            return "number";
        case "float":
            return "number";
        case "date":
            return "Date";
        case "json":
            return "object";
        case "bigint":
            return "bigint";
        default:
            return typeFn;
    }
}

const command$4 = new commander.Command("add")
    .description("Generate a bot component or add a dependency")
    .addCommand(command$a)
    .addCommand(command$6)
    .addCommand(command$8)
    .addCommand(command$5)
    .addCommand(command$9)
    .addCommand(command$b)
    .addCommand(command$7)
    .action(async () => {
    const component = await prompts.select({
        message: "Select a component to add",
        choices: [
            { name: "Command", value: "cmd" },
            { name: "Slash Command", value: "slash" },
            { name: "Listener", value: "listener" },
            { name: "Table", value: "table" },
            { name: "Cron Job", value: "cron" },
            { name: "Button", value: "button" },
            { name: "Namespace", value: "namespace" },
        ],
    });
    switch (component) {
        case "cmd":
            return handler$7();
        case "slash":
            return handler$3();
        case "listener":
            return handler$5();
        case "table":
            return handler$2();
        case "cron":
            return handler$6();
        case "button":
            return handler$8();
        case "namespace":
            return handler$4();
    }
});

const handler$1 = async () => {
    if (!isBotTsProject())
        return process.exit(1);
    // TODO: fetch the current database client
    const baseClient = getDatabaseDriverName(readJSON(cwd("package.json")));
    const { database, client } = await promptDatabase();
    if (client !== baseClient) {
        console.warn(`‚ö†Ô∏è You'll probably need to transfer the old data to the new database client`);
        const backup = await prompts.confirm({
            message: "Do you want to backup the database before proceeding?",
            default: true,
        });
        if (backup) {
            console.error(`${util__namespace.styleText("red", "The backup command is not yet automated.")}\nPlease backup manually using the @ghom/orm documentaiton.\nhttps://www.npmjs.com/package/@ghom/orm#Backup`);
            return process.exit(1);
        }
    }
    await setupDatabase({ client, ...database }, cwd());
    if (client !== baseClient) {
        const { components } = readJSON(cwd("compatibility.json"));
        const env = dotenv.parse(fs.readFileSync(cwd(".env"), "utf8"));
        console.log();
        await loader("installing", () => {
            cp.execSync(components["install"][env.PACKAGE_MANAGER], {
                stdio: "ignore",
            });
        }, "installed");
    }
    console.log();
    console.log(`‚úÖ Database has been configured.`);
};
const command$3 = new commander.Command("database")
    .description("Setup database\nMore info: https://ghom.gitbook.io/bot.ts/usage/use-database")
    .usage("[--options]")
    .action(handler$1);

const handler = async () => {
    if (!isBotTsProject())
        return process.exit(1);
    const engine = await promptEngine();
    const setupDocker = await prompts.confirm({
        message: "Do you want to overwrite the Dockerfile and compose.yml?",
        default: false,
    });
    console.log();
    await loader("Updating engine", () => setupEngine(engine, { setupDocker }), "Updated engine");
    console.log();
    console.log("‚úÖ Engine has been configured");
};
const command$2 = new commander.Command("engine")
    .description("Set the engine for the project\nMore info: https://ghom.gitbook.io/bot.ts/configuration#switch-engine")
    .usage("[--options]")
    .action(handler);

// set database <sqlite3 | pg | "mysql2">
// set engine <node | bun | deno> <npm | yarn | pnpm | bun | deno>
const command$1 = new commander.Command("config")
    .description("Update bot.ts project configurations")
    .usage("[command] [--options]")
    .addCommand(command$3)
    .addCommand(command$2)
    .action(async () => {
    const component = await prompts.select({
        message: "Select a component to configure",
        choices: [
            { name: "Database", value: "database" },
            { name: "Engine", value: "engine" },
        ],
    });
    switch (component) {
        case "database":
            return handler$1();
        case "engine":
            return handler();
    }
});

const command = new commander.Command("new")
    .description("Generate a typescript bot")
    .option("-b, --branch <branch>", "Branch to clone the boilerplate from", "master")
    .action(async (options) => {
    // base config
    const name = await inputName("Enter the bot name", {
        defaultValue: "bot-ts",
        kebabCase: true,
    });
    const description = await prompts.input({
        message: `Enter a short description for the bot ${util__namespace.styleText("grey", "(one line)")}`,
    });
    const location = await prompts.input({
        message: `Where will the bot be located? ${util__namespace.styleText("grey", "(here by default)")}`,
        default: ".",
    });
    const prefix = await prompts.input({
        message: `Enter the bot prefix ${util__namespace.styleText("grey", "(for textual commands)")}`,
        default: ".",
    });
    const locale = await prompts.select({
        message: "Enter the default bot locale",
        default: "en",
        choices: readJSON(root("locales.json")),
    });
    const token = await prompts.password({
        message: `Enter the bot token ${util__namespace.styleText("grey", "(needed for configuration)")}`,
        async validate(value) {
            if (!value.trim())
                return "Bot token is required";
            try {
                const response = await fetch("https://discord.com/api/v10/users/@me", {
                    headers: {
                        Authorization: `Bot ${value}`,
                    },
                });
                if (response.status === 200)
                    return true;
                return `Invalid token (code ${response.status})`;
            }
            catch {
                return "Internal error";
            }
        },
    });
    const project = (...segments) => cwd(location, name, ...segments);
    let onverwrite = false;
    if (isNodeLikeProject(project())) {
        const confirmOverwrite = await prompts.confirm({
            message: `Do you want to ${util__namespace.styleText("red", "overwrite the existing project")}?`,
            default: false,
        });
        if (!confirmOverwrite) {
            console.log(util__namespace.styleText("red", "Aborted."));
            process.exit(0);
        }
        onverwrite = true;
    }
    const { runtime, packageManager } = await promptEngine();
    // database
    const { database, client } = await promptDatabase();
    const readme = await prompts.confirm({
        message: "Do you want to generate a README.md?",
        default: false,
    });
    const ready = await prompts.confirm({
        message: "Ready to generate bot files?",
        default: true,
    });
    if (!ready) {
        console.log(util__namespace.styleText("red", "Aborted."));
        process.exit(0);
    }
    // generate!
    console.log();
    const warns = [];
    let app, scripts;
    // validate all data before building any files
    await loader("Validating data", async () => {
        app = await fetch("https://discord.com/api/v10/applications/@me", {
            headers: {
                Authorization: `Bot ${token}`,
            },
        })
            .then((res) => res.json())
            .then((data) => data);
        if (!app.owner) {
            console.error("Failed to fetch application owner");
            process.exit(1);
        }
    }, "Validated data");
    if (onverwrite) {
        await loader("Remove existing project", async () => {
            await fs.promises.rm(project(), { recursive: true });
        }, "Removed existing project");
    }
    // download the boilerplate from github
    await loader("Downloading boilerplate", () => cp.execSync([
        "git clone",
        "--depth=1",
        "--single-branch",
        `--branch=${options.branch}`,
        "https://github.com/bot-ts/framework.git",
        `"${project()}"`,
    ].join(" "), { stdio: ["ignore", "ignore", "pipe"] }), "Downloaded boilerplate");
    await loader("Initializing configuration", async () => {
        await fs.promises.writeFile(project(".env"), "", "utf8");
        await injectEnvLine("BOT_MODE", "development", project());
        await injectEnvLine("BOT_PREFIX", prefix, project());
        await injectEnvLine("BOT_LOCALE", locale, project());
        await injectEnvLine("BOT_TOKEN", token, project());
        await injectEnvLine("BOT_NAME", name, project());
        await injectEnvLine("BOT_ID", app.id, project());
        await injectEnvLine("BOT_OWNER", app.owner.id, project());
        scripts = await setupEngine({ runtime, packageManager }, { setupDocker: true }, project());
        await setupDatabase({ client, ...database }, project());
    }, "Initialized configuration");
    // TODO: update package.json scripts with base.path:scripts/generate-scripts.js
    await loader("Installing dependencies", async () => {
        await fs.promises.copyFile(project("lockfiles", scripts["lockfile"][packageManager]), project(scripts["lockfile"][packageManager]));
        cp.execSync(scripts["ci"][packageManager], {
            cwd: project(),
            stdio: ["ignore", "ignore", "pipe"],
        });
    }, "Installed dependencies");
    await loader("Finishing setup", async () => {
        try {
            await fs.promises.unlink(project(".factory.readme.js"));
            await fs.promises.unlink(project(".factory.lockfiles.js"));
            await fs.promises.unlink(project(".github", "workflows", "factory.yml"));
            await fs.promises.rm(project("lockfiles"), { recursive: true });
            await fs.promises.rm(project(".git"), { recursive: true });
        }
        catch (err) {
            warns.push("failure to clean up some boilerplate files");
        }
        const packageJson = readJSON(project("package.json"));
        writeJSON(project("package.json"), {
            ...packageJson,
            name,
            description,
            author: app.owner.username,
        });
        if (readme) {
            try {
                cp.execSync(`${scripts["run"][packageManager]} readme`, {
                    cwd: project(),
                    stdio: ["ignore", "ignore", "pipe"],
                });
            }
            catch (error) {
                warns.push("failure to generate README.md");
            }
        }
    }, "Finished setup");
    if (warns.length > 0) {
        console.log();
        warns.map((warn) => console.warn(util__namespace.styleText("yellow", `‚ö†Ô∏è ${warn}`)));
    }
    console.log();
    console.log(`‚úÖ ${util__namespace.styleText("blueBright", name)} bot has been created.`);
    console.log(`üìÇ ${util__namespace.styleText("cyanBright", project())}`);
    process.exit(0);
});

const dirname = path.dirname(url.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('index.js', document.baseURI).href))));
const bot = commander.program
    .name("bot")
    .description("Bot.ts is a modern framework for creating Discord bots with TypeScript.")
    .usage("<cmd> [args] [--options]")
    .version(readJSON(path.join(dirname, "..", "package.json")).version)
    .addCommand(command)
    .addCommand(command$4)
    .addCommand(command$1);
if (isBotTsProject()) {
    const compatibility = readJSON(cwd("compatibility.json"));
    const botEnv = dotenv.config({
        path: cwd(".env"),
    });
    for (const [key, value] of Object.entries(compatibility.components)) {
        if (key === "lockfile")
            continue;
        const [name, sub] = key.split("-");
        const run = "node" in value
            ? value[botEnv.parsed.RUNTIME]
            : value[botEnv.parsed.PACKAGE_MANAGER];
        let cmd = bot.commands.find((cmd) => cmd.name() === name);
        if (!cmd) {
            cmd = new commander.Command(name)
                .description(`Run the "${run}" command`)
                .usage("[args] [--options]");
            bot.addCommand(cmd);
        }
        const action = async () => {
            cp.execSync(`${run} ${process.argv.slice(2).join(" ")}`, {
                cwd: process.cwd(),
            });
        };
        if (!sub) {
            cmd.action(action);
        }
        else {
            cmd.addCommand(new commander.Command(sub)
                .description(sub === "dev"
                ? "Add a dev dependency"
                : sub === "global"
                    ? "Add a global dependency"
                    : "Add a dependency")
                .action(action));
        }
    }
}
bot.action(() => commander.program.help());
commander.program.parse();
