import url from "url";
import { Handler } from "@ghom/handler";
import { default as knex } from "knex";
import { isCJS } from "./util.js";
import { Table } from "./table.js";
import { ResponseCache } from "./caching.js";
import { backupTable, restoreBackup, disableForeignKeys, enableForeignKeys, } from "./backup.js";
export class ORM {
    config;
    _ready = false;
    database;
    handler;
    _rawCache;
    constructor(config) {
        this.config = config;
        this.database = knex(config.database ?? {
            client: "sqlite3",
            useNullAsDefault: true,
            connection: {
                filename: ":memory:",
            },
        });
        this.handler = new Handler(config.tableLocation, {
            loader: (filepath) => import(isCJS ? filepath : url.pathToFileURL(filepath).href).then((file) => file.default),
            pattern: /\.js$/,
        });
        this._rawCache = new ResponseCache((raw) => this.raw(raw), config.caching ?? Infinity);
    }
    get cachedTables() {
        return [...this.handler.elements.values()];
    }
    get cachedTableNames() {
        return this.cachedTables.map((table) => table.options.name);
    }
    hasCachedTable(name) {
        return this.cachedTables.some((table) => table.options.name === name);
    }
    async hasTable(name) {
        return this.database.schema.hasTable(name);
    }
    /**
     * Handle the table files and create the tables in the database.
     */
    async init() {
        await this.handler.init();
        try {
            await enableForeignKeys(this);
        }
        catch { }
        this.handler.elements.set("migration", new Table({
            name: "migration",
            priority: Infinity,
            setup: (table) => {
                table.string("table").unique().notNullable();
                table.integer("version").notNullable();
            },
        }));
        const sortedTables = this.cachedTables.toSorted((a, b) => (b.options.priority ?? 0) - (a.options.priority ?? 0));
        for (const table of sortedTables) {
            table.orm = this;
            await table.make();
        }
        this._ready = true;
    }
    raw(sql) {
        if (this._ready)
            this.cache.invalidate();
        return this.database.raw(sql);
    }
    cache = {
        raw: (sql, anyDataUpdated) => {
            if (anyDataUpdated)
                this.cache.invalidate();
            return this._rawCache.get(sql, sql);
        },
        invalidate: () => {
            this._rawCache.invalidate();
            this.cachedTables.forEach((table) => table.cache.invalidate());
        },
    };
    clientBasedOperation(operation) {
        const client = (this.config.database?.client ?? "sqlite3");
        return operation[client]?.();
    }
    /**
     * Create a backup of the database. <br>
     * The backup will be saved in the location specified in the config.
     */
    async createBackup(dirname) {
        for (let table of this.cachedTables) {
            await backupTable(table, dirname);
        }
        console.log("Database backup created.");
    }
    /**
     * Restore the database from the backup. <br>
     * @warning This will delete all the data in the tables.
     */
    async restoreBackup(dirname) {
        await disableForeignKeys(this, async (trx) => {
            for (let table of this.cachedTables) {
                await restoreBackup(table, trx, dirname);
            }
        });
        console.log("Database restored from backup.");
    }
}
