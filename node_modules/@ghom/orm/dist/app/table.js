import util from "util";
import { ResponseCache } from "./caching.js";
import { DEFAULT_LOGGER_DESCRIPTION, DEFAULT_LOGGER_HIGHLIGHT, DEFAULT_LOGGER_RAW_VALUE, } from "./util.js";
export class Table {
    options;
    orm;
    _whereCache;
    _countCache;
    constructor(options) {
        this.options = options;
    }
    get db() {
        if (!this.orm)
            throw new Error("missing ORM");
        return this.orm.database;
    }
    get query() {
        return this.db(this.options.name);
    }
    get cache() {
        if (!this._whereCache || !this._countCache)
            throw new Error("missing cache");
        if (!this.orm)
            throw new Error("missing ORM");
        return {
            get: (id, cb) => {
                return this._whereCache.get(id, cb);
            },
            set: (cb) => {
                // todo: invalidate only the related tables
                this.orm.cache.invalidate();
                return cb(this.query);
            },
            count: (where) => {
                return this._countCache.get(where ?? "*", where ?? null);
            },
            invalidate: () => {
                this._whereCache.invalidate();
                this._countCache.invalidate();
                this.orm._rawCache.invalidate();
            },
        };
    }
    async count(where) {
        return this.query
            .select(this.db.raw("count(*) as total"))
            .whereRaw(where ?? "1=1")
            .then((rows) => +(rows?.[0] ?? { total: 0 }).total);
    }
    async hasColumn(name) {
        return this.db.schema.hasColumn(this.options.name, name);
    }
    async getColumn(name) {
        return this.db(this.options.name).columnInfo(name);
    }
    async getColumns() {
        return this.db(this.options.name).columnInfo();
    }
    async getColumnNames() {
        return this.getColumns().then(Object.keys);
    }
    async isEmpty() {
        return this.count().then((count) => count === 0);
    }
    async make() {
        if (!this.orm)
            throw new Error("missing ORM");
        this._whereCache = new ResponseCache((cb) => cb(this.query), this.options.caching ?? this.orm?.config.caching ?? Infinity);
        this._countCache = new ResponseCache((where) => this.count(where ?? undefined), this.options.caching ?? this.orm?.config.caching ?? Infinity);
        try {
            await this.db.schema.createTable(this.options.name, this.options.setup);
            this.orm.config.logger?.log(`created table ${util.styleText(this.orm.config.loggerStyles?.highlight ?? DEFAULT_LOGGER_HIGHLIGHT, this.options.name)}${this.options.description
                ? ` ${util.styleText(this.orm.config.loggerStyles?.description ??
                    DEFAULT_LOGGER_DESCRIPTION, this.options.description)}`
                : ""}`);
        }
        catch (error) {
            if (error.toString().includes("syntax error")) {
                this.orm.config.logger?.error(`you need to implement the "setup" method in options of your ${util.styleText(this.orm.config.loggerStyles?.highlight ?? DEFAULT_LOGGER_HIGHLIGHT, this.options.name)} table!`);
                throw error;
            }
            else {
                this.orm.config.logger?.log(`loaded table ${util.styleText(this.orm.config.loggerStyles?.highlight ?? DEFAULT_LOGGER_HIGHLIGHT, this.options.name)}${this.options.description
                    ? ` ${util.styleText(this.orm.config.loggerStyles?.description ??
                        DEFAULT_LOGGER_DESCRIPTION, this.options.description)}`
                    : ""}`);
            }
        }
        try {
            const migrated = await this.migrate();
            if (migrated !== false) {
                this.orm.config.logger?.log(`migrated table ${util.styleText(this.orm.config.loggerStyles?.highlight ?? DEFAULT_LOGGER_HIGHLIGHT, this.options.name)} to version ${util.styleText(this.orm.config.loggerStyles?.rawValue ?? DEFAULT_LOGGER_RAW_VALUE, String(migrated))}`);
            }
        }
        catch (error) {
            this.orm.config.logger?.error(error);
            throw error;
        }
        if ((await this.count()) === 0)
            await this.options.then?.bind(this)(this);
        return this;
    }
    async migrate() {
        if (!this.options.migrations)
            return false;
        const migrations = new Map(Object.entries(this.options.migrations)
            .sort((a, b) => Number(a[0]) - Number(b[0]))
            .map((entry) => [Number(entry[0]), entry[1]]));
        const fromDatabase = await this.db("migration")
            .where("table", this.options.name)
            .first();
        const data = fromDatabase || {
            table: this.options.name,
            version: -Infinity,
        };
        const baseVersion = data.version;
        await this.db.schema.alterTable(this.options.name, (builder) => {
            migrations.forEach((migration, version) => {
                if (version <= data.version)
                    return;
                migration(builder);
                data.version = version;
            });
        });
        await this.db("migration")
            .insert(data)
            .onConflict("table")
            .merge();
        return baseVersion === data.version ? false : data.version;
    }
}
